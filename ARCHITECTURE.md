# Aither Flow — Архитектура V2

**Дата:** 2026-02-27
**Статус:** в обсуждении

---

## Суть проекта

Desktop GUI для Claude Code CLI. Не замена CLI, а полноценная визуальная обёртка.
Пользователю нужны два приложения: Claude Code CLI + Aither Flow.

## Стек

- **Бэкенд:** Rust / Tauri 2
- **Фронтенд:** React + TypeScript + Tailwind CSS + Vite
- **Тема:** Gruvbox (dark/light)
- **Данные:** SQLite (память), JSON-файлы (чаты, настройки)

---

## Два главных блока

### Блок 1: Нативная совместимость с CLI

GUI читает и пишет те же файлы что CLI. Не дублирует, не изобретает свои форматы.

| Что | Где хранится | Формат |
|-----|-------------|--------|
| Навыки | `~/.claude/skills/`, `.claude/skills/` | SKILL.md с YAML frontmatter |
| Агенты | `~/.claude/agents/`, `.claude/agents/` | .md с YAML frontmatter |
| MCP-серверы | `~/.claude.json` (глоб), `.mcp.json` (проект) | JSON |
| Хуки | `~/.claude/settings.json`, `.claude/settings.json` | JSON |
| Разрешения | тот же `settings.json` | JSON (allow/deny/ask) |
| Плагины | `~/.claude/plugins/` | CLI-формат |
| CLAUDE.md | `~/.claude/CLAUDE.md` (глоб), `.claude/CLAUDE.md` (проект) | Markdown |
| Модели | sonnet / opus / haiku | CLI резолвит по алиасу |
| Стриминг | stream-json протокол | `--output-format stream-json` |
| Все CLI-флаги | аргументы при запуске | `--resume`, `--agent`, `--mcp-config`... |

**Принцип:** если CLI имеет стандартный формат — GUI его использует. Никаких параллельных хранилищ.

### Блок 2: Только GUI (уникальная ценность)

Фичи которых нет в CLI, или GUI реализует значительно лучше.

#### Чаты (именованные сессии)
- CLI хранит сессии как UUID-файлы без названий
- GUI: именованные чаты, закрепление, папки, привязка к агентам
- Хранение: `~/.config/claude-gui/chats/` (JSON)

#### Карточки памяти
- CLI имеет текстовый MEMORY.md (свалка заметок агента)
- GUI: структурированные карточки (заголовок, категория, теги), полнотекстовый поиск, фильтры
- Хранение: SQLite + FTS5
- Скилл `/recall` прикрепляет все карточки проекта как контекст
- Две системы (GUI SQLite и CLI MEMORY.md) работают параллельно, не мешают

#### Мульти-агенты
- CLI: одна сессия
- GUI: несколько вкладок, каждая со своим CLI-процессом, проектом, чатом
- **Архитектурное требование V2:** полная изоляция агентов с первого дня (см. ниже)

#### Просмотрщик файлов
- Подсветка синтаксиса, номера строк
- Diff в реальном времени (при Edit/Write/MultiEdit)
- Accept / Reject правок
- Просмотр картинок с зумом
- Табы открытых файлов

#### Веб-превью
- iframe для dev-серверов
- Проверка доступности сервера
- Порты-закладки

#### Визуальные редакторы
- Хуки (20 событий вкл. WorktreeCreate/WorktreeRemove, 3 типа обработчиков)
- Разрешения (allow/deny/ask правила)
- MCP-серверы (добавить/удалить/тест/импорт)
- Агенты (CRUD, YAML-поля)
- Навыки (CRUD, переменные)

#### Интерактивные карточки в чате
- AskUserQuestion — вопросы агента с вариантами ответа
- ExitPlanMode — утверждение планов
- **V2:** Интерактивные разрешения (Allow/Deny) через встроенный MCP

#### Остальное
- Статистика использования (SVG-графики)
- Телеграм-бот (встроенный, данные пользователя)
- Голосовой ввод (cpal + Groq Whisper)
- Файловый менеджер с операциями
- Поиск по проекту (файлы + содержимое)
- Закладки проектов с переименованием
- Темы (Gruvbox dark/light)
- Горячие клавиши
- Перетаскивание файлов, вставка картинок из буфера

---

## Философия: дирижёр и оркестр

Приложение — оркестр. Есть одно маленькое ядро (дирижёр), и есть секции
инструментов (модули). Дирижёр общается с CLI и раздаёт события. Секции
играют свои партии, друг о друге не знают.

```
Ядро (дирижёр)
  └── понимает CLI, stream-json, процессы
  └── раздаёт события модулям через шину

Струнные (данные пользователя):
  ├── Чаты — именованные сессии, папки, закрепление
  ├── Память — карточки, SQLite, поиск
  └── Проекты — закладки, настройки, доп. директории

Духовые (расширения CLI):
  ├── Навыки — SKILL.md, библиотека, коллекции
  ├── MCP-серверы — управление, тест, OAuth
  ├── Агенты — CRUD, worktree, роли
  └── Хуки — события, разрешения, правила

Ударные (инфраструктура):
  ├── Файл-вьюер — подсветка, diff, табы
  ├── Веб-превью — iframe, порты, dev-серверы
  ├── Telegram / Relay — удалённое взаимодействие
  └── Крон / Демон — фоновые задачи
```

**Правило:** ни один модуль не импортирует другой напрямую. Общение — через
события (шину) или через ядро. Если убрать модуль «Веб-превью» — остальное
продолжит работать. Модуль можно переписать с нуля, не трогая остальные.

В V1 всё было в одном файле (Layout.tsx, 2600 строк, 150 переменных).
Обновления ломали всё. В V2 — обновляешь один модуль, остальные не знают.

---

## Архитектурные решения V2

### 1. Изоляция агентов — фундамент, не заплатка

В V1 один общий стейт + activeAgentId → утечки между агентами → заплатки C4-C8.

**В V2:** каждый агент — самостоятельный контейнер:
- Свои сообщения, сессия, проект, чат, CLI-процесс
- Переключение вкладки = показ другого контейнера, не перенастройка общего стейта
- Фоновый агент работает независимо
- Нет общего `activeAgentId` в бизнес-логике
- Проблемы C4-C8 не возникают архитектурно

### 2. Интерактивные разрешения — отдельный маленький бинарник

**Проблема:** CLI в режиме трубы (`-p`) молча решает сам — разрешить или
отказать. Событие «жду разрешения» не приходит в JSON-поток. GUI не знает
что CLI хотел спросить. SDK от Anthropic решает это тем же способом.

**Решение:** отдельный маленький бинарник `aither-flow-perms` (~200 строк Rust).
Без Tauri, без окна, без тяжёлых зависимостей. Собирается в одном проекте
с основным приложением (Cargo workspace).

Схема:
```
GUI (Tauri, основное окно)
  ├── запускает Claude CLI с --permission-prompt-tool
  └── CLI запускает aither-flow-perms (крошечный, без окна)
        ├── stdin/stdout → MCP-протокол → CLI
        └── unix socket → GUI (карточка Allow/Deny в чате)
```

Реализация MCP-протокола минимальная — 3 метода JSON-RPC:
- `initialize` — рукопожатие
- `tools/list` — один инструмент
- `tools/call` — запрос разрешения

Три уровня (как в CLI, первые два уже работают):
1. allow-правила в settings.json → пропускает автоматически (MCP не вызывается)
2. deny-правила → блокирует автоматически (MCP не вызывается)
3. Всё остальное → MCP вызывается → карточка в чате (Allow / Allow Always / Deny)

### 3. Контекст агента

Агент всегда знает что работает из GUI (через MCP или system prompt).
GUI передаёт агенту файлы которые пользователь открыл САМИ (вручную),
НЕ автоматически открытые при просмотре агентом.

### 4. Уведомления

Системные уведомления на рабочий стол (notify-send / нативные).
Агент закончил задачу, нашёл ошибку, ждёт ответа → уведомление.
Без привязки к телеграму.

### 5. Визард первого запуска

При первом запуске (нет `~/.claude/CLAUDE.md`):
- Язык общения
- Стиль (формальный / свободный)
- Уровень (программист / не программист)
- Свободное поле

Генерирует `~/.claude/CLAUDE.md` из шаблона + ответов.

### 6. Редактор глобального CLAUDE.md

В настройках пользователя — возможность читать и редактировать
`~/.claude/CLAUDE.md` прямо из приложения. Это файл который влияет
на поведение агента во ВСЕХ проектах.

### 7. Удалённое взаимодействие (Telegram + Relay + уведомления)

Всё что связано с общением с агентом НЕ из окна приложения — один блок.

**Телеграм-бот** (переносится из V1, дорабатывается):
- Отправка/приём сообщений через Telegram
- Стриминг ответов (editMessage, обновление на лету, throttle 2-3 сек)
- Дебаунс входящих (5 сообщений подряд → склеить в одно, пауза 2 сек)
- Уведомления по событиям (задача готова, ошибка, ждёт ввода)
- Пользователь вводит свои данные (токен, chat_id, API-ключ)

**Relay-сервер** (позже, закладывается в архитектуру):
- GUI где угодно ↔ relay (облако) ↔ CLI-сервер где угодно
- WebSocket в обе стороны, E2E-шифрование
- Relay не хранит данные, только маршрутизирует
- Подробности: `V2/10-relay-server-monetization.md`

**Каналы доставки** (абстракция):
- Telegram, desktop-уведомления, email (SMTP), webhook, звук
- Единый интерфейс — настраивается на уровне крон-задачи или глобально

**Общий принцип:** агент доступен всегда — через окно, через Telegram,
через relay с телефона. Способ связи не влияет на возможности.

### 8. Модульная структура интерфейса

В V1 всё в одном Layout.tsx (2600 строк, 150 переменных состояния).
В V2 — изолированные модули, каждый со своим состоянием:

| # | Модуль | Что делает | Не знает о |
|---|--------|-----------|------------|
| 1 | **Чат** | Сообщения, стриминг, ввод, интерактивные карточки | Файл-вьюере, веб-превью |
| 2 | **Боковая панель** | Вкладки, порядок, раскрытие. Внутри — мини-модули (чаты, файлы, память, MCP...) | Чате, модалках |
| 3 | **Настройки** | Одно модальное окно, список разделов слева (как в браузере). Конкретные разделы — при реализации | Всём остальном |
| 4 | **Веб-превью** | Отдельная панель (не вкладка файл-вьюера). URL, порт, проверка сервера | Файл-вьюере |
| 5 | **Файл-вьюер** | Подсветка, diff, accept/reject, табы, редактирование | Веб-превью, чате |
| 6 | **Модалки** | Единая система. Один базовый компонент Modal, все оверлеи строятся поверх | — |
| 7 | **Статус-бар** | Полоска внизу (модель, токены, стоимость, контекст) + раскрывающиеся панели | Чате, панелях |
| 8 | **Хедер** | Кнопки управления (Dev, Build, Chrome, закрытие) | Всём кроме глобального состояния |

Модалки: в V1 каждый оверлей написан по-своему (разные стили, логика закрытия,
анимации). В V2 — единый компонент Modal с единым поведением.

Веб-превью: отвязан от файл-вьюера — отдельная панель которую можно
открыть рядом с чем угодно, а не вкладка внутри файлового просмотрщика.

Статус-бар: не просто строка, а зона с раскрывающимися панелями (как в VS Code):
- **Строка статуса** — всегда видна: модель, токены, стоимость, % контекста
- **Панель инструментов** (раскрывается вверх) — что агент делает сейчас.
  Карточки инструментов, иерархия подагентов, кликабельные пути к файлам
- **Панель логов** (раскрывается вверх) — сырые логи CLI.
  Если что-то падает — можно раскрыть и посмотреть что происходит под капотом

### 9. Перевод контента (не локализация)

Интерфейс приложения — всегда на английском. Не меняется.

Но описания навыков, MCP-серверов, агентов, плагинов — приходят на
английском от авторов. Пользователь может захотеть видеть их на своём языке.

**Что переводится** (настраиваемо, чекбоксы):
- Описания навыков (тултипы, карточки)
- Описания MCP-серверов
- Описания агентов
- Подсказки в интерфейсе
- Всё что показывается во всплывающих окнах

**Что НЕ переводится:**
- Интерфейс (кнопки, меню, заголовки) — всегда английский
- Код, пути к файлам, техническая информация

**Настройка:** в Settings — выбор языка перевода + чекбоксы «что переводить».
В V1 уже работают переводы тултипов навыков — расширить на всё остальное.

### 10. Крон-задачи (фоновые по расписанию)


Запуск агента по расписанию с промптом. Результат — в любой канал доставки.

**Примеры:**
- «Каждое утро в 9:00 проверь почту и скинь сводку»
- «Каждый час мониторь CI, если упало — напиши»
- «В пятницу вечером — отчёт по неделе»
- «Раз в день проверь обновления зависимостей»

**Каждая задача:** имя, cron-выражение, промпт, проект, модель,
канал доставки (Telegram / уведомление / webhook / без),
режим (чистая сессия каждый раз / продолжение существующего чата).

**Хранение:** `~/.config/aither-flow/cron-jobs.json`

**Связь с фоновым демоном:** крон-задачи работают только при запущенном
приложении (или фоновом сервисе). Без демона — только пока окно открыто.

### 11. Фоновый демон (background service)

CLI-процессы продолжают работать после закрытия GUI-окна.

- systemd user service (Linux) / launchd (macOS)
- Telegram-бот + CLI-процессы работают в фоне
- GUI при запуске подключается к существующему сервису (Unix socket)
- При закрытии GUI: «Убить агентов или оставить в фоне?»
- Крон-задачи (п.10) без демона работают только пока окно открыто
- **Иконка в трее:** когда демон запущен — иконка в system tray.
  Статус агентов, быстрое открытие окна. Tauri 2 поддерживает из коробки

**Хранение:** `~/.config/aither-flow/daemon.json`

### 12. Worktree isolation (изоляция в Git)

Агент работает в отдельной копии Git-репозитория, не трогая основной проект.

- Несколько агентов параллельно в одном проекте без конфликтов файлов
- Рискованные задачи в песочнице (не насрёт в рабочую папку)
- Результат сливается обратно только если устраивает
- CLI уже умеет: `--worktree` флаг, `isolation: worktree` в frontmatter агента
- GUI: чекбокс в редакторе агента + передача флага при запуске CLI
- Хук-события `WorktreeCreate` / `WorktreeRemove` — поддержать в HooksEditor

### 13. Откат сессии с восстановлением файлов (Rewind) — MUST HAVE

CLI делает снимок файлов перед каждым сообщением пользователя.
Бэкапы в `~/.claude/file-history/<session-uuid>/` (полные копии).

**Как работает в CLI:**
- Двойной Escape или `/rewind` → список сообщений → 4 варианта:
  1. Откатить файлы + разговор
  2. Только разговор (файлы оставить)
  3. Только файлы (разговор оставить)
  4. Сжать разговор от этой точки
- Отслеживаются только Edit/Write/MultiEdit (НЕ bash-команды)

**Как сделать в GUI (pipe-режим):**
- Переменная `CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING=1`
- Флаг `--replay-user-messages` → UUID чекпоинтов в потоке
- Откат файлов: `claude --resume <sid> --rewind-files <checkpoint-uuid>`
- GUI: кнопка «Откатить» на каждом сообщении пользователя
- Предпросмотр: какие файлы изменятся при откате

### 14. Запуск из терминала (CLI-аргументы)

Приложение можно запускать из терминала с аргументами:

```
aither-flow --project /path/to/project --model opus --agent reviewer
```

- `--project <path>` — открыть проект
- `--model <name>` — установить модель (sonnet/opus/haiku)
- `--agent <name>` — активировать агента
- `--help`, `--version`
- Поддержка путей с пробелами, `~`, относительных

### 15. Выбор бинарника Claude CLI

Автоматический поиск всех установленных версий CLI в системе.
Пользователь выбирает какую версию использовать через настройки.
Полезно при нескольких установках (npm, homebrew, manual).

### 16. Skill Sources (коллекции навыков)

Подтягивание коллекций навыков из awesome-репозиториев и других источников.

- Вкладка «Sources» в библиотеке навыков
- Клонирование/обновление из Git-репозиториев
- Установка навыков в `~/.claude/skills/`

### 17. Project Saves (снимки проекта)

Снимки состояния проекта — как сейвы в играх.

- Сохранить текущее состояние всех файлов проекта
- Откатить к любому сохранению
- Список сохранений с названиями и датами
- Независимо от Git (работает даже без репозитория)

### 18. Новые фичи CLI (февраль 2026) — отслеживать

Anthropic активно развивает CLI. Новые возможности которые влияют на GUI:

**Previews** (20 фев) — автоматический предпросмотр работающих приложений,
ревью кода, обработка CI-ошибок и PR в фоне. Расширяет наш Web Preview —
возможно CLI сам будет давать URL для предпросмотра.

**Claude Code Security** (20 фев, research preview) — сканирование кодовых
баз на уязвимости с предложением патчей. Отдельный режим/инструмент CLI.
GUI может добавить кнопку «Проверить безопасность» которая запускает этот режим.

**Remote Control** (25 фев, research preview для Max) — продолжение сессии
с телефона через claude.ai/code. GUI просто поддерживает команду `/rc` —
QR-код появляется в чате, пользователь сканирует, готово. Трафик через
серверы Anthropic (они видят содержимое), только Max-подписка.
Наш Relay — альтернатива: бесплатно, E2E-шифрование, свой сервер.

**Auto-memory** (27 фев) — CLI автоматически запоминает выученное между
сессиями. **Пересекается с нашими карточками памяти.** Нужно понять: это
расширение MEMORY.md или новая система? Как сосуществуют с нашей SQLite-памятью?

**Принцип:** следить за развитием CLI и адаптироваться. Не изобретать то
что CLI скоро сделает сам. Но и не ждать — делать своё где GUI даёт лучший UX.

### 19. Менеджер сессий

Отдельный большой блок, продумывается позже.

CLI хранит сессии как JSONL с DAG-структурой (parentUuid).
GUI может визуализировать дерево сессий (fork-и, resume-ы).
Возможно пересекается с чатами и памятью.

### 20. Единый набор иконок (icon pack)

В V1 иконки — бардак: часть в `icons.tsx` как компоненты, часть — инлайн-SVG
раскиданные по десяткам файлов. Разный стиль, разные размеры, нет системы.

**В V2:** один icon pack, один стиль, один источник.

**Варианты:**
- Готовый пак (Lucide, Phosphor, Tabler Icons) — бесплатные, единый стиль,
  сотни иконок, tree-shakeable (в бандл попадают только используемые)
- Свой пак — уникальность, но долго рисовать

**Требования:**
- Все иконки из одного импорта (`import { Search, File, Settings } from ...`)
- Единый размер, толщина линий, стиль
- Поддержка цветов через CSS-переменные (Gruvbox)
- Никаких инлайн-SVG в компонентах

### 21. Кроссплатформенные детали (platform.rs)

Linux — основная платформа разработки, macOS — для тестов.
В V1 много линуксовых хардкодов. В V2 — `platform.rs` с первого дня.

**Что отличается между платформами:**
- Буфер обмена (X11/Wayland vs macOS)
- Уведомления (notify-send vs NSNotification)
- Пути (XDG vs ~/Library/)
- Процессы (kill, сигналы, PID-файлы)
- Автозапуск (systemd vs launchd)
- Шрифты и рендеринг (WebKitGTK vs WKWebView)
- Трей (разные API)
- Env vars при запуске (GDK_BACKEND и пр. на Linux)

**Принцип:** `platform.rs` экспортирует функции с единым интерфейсом,
внутри — `#[cfg(target_os)]` блоки. Остальной код не знает про ОС.

### 22. MCP OAuth (client-id / client-secret)

CLI добавил OAuth-креденшалы для MCP-серверов (Azure AD, Entra ID и пр.).

- В редакторе MCP-серверов: поля client ID и client secret
- Secret вводится с маскировкой (как пароль)
- Хранение: системный keychain (НЕ в .mcp.json открытым текстом)

### 23. Авторизация CLI

CLI имеет отдельные команды: `claude auth login`, `claude auth status`,
`claude auth logout`.

- GUI показывает статус авторизации (в настройках или статус-баре)
- Если токен сдох — кнопка «Перелогиниться»
- Смена аккаунта (если понадобится)

### 24. Отслеживание изменений файлов (file watching)

Когда файл изменился на диске (другой агент, другой процесс, руками) —
FileViewer должен обновиться.

- `notify` crate (уже есть в экосистеме Tauri)
- Наблюдение за открытыми файлами и деревом проекта
- Автообновление содержимого FileViewer при изменении
- Обновление FileTree при создании/удалении файлов

### 25. Поиск по истории чатов

Поиск по проекту (Alt+F) ищет файлы и их содержимое.
Поиск по тексту старых чатов — нет.

- Полнотекстовый поиск по всем чатам проекта
- Результаты: чат, дата, фрагмент текста с подсветкой совпадения
- Клик → открыть чат и прокрутить к сообщению

### 26. Экспорт / импорт данных

Перенос данных между машинами.

- Экспорт: чаты, карточки памяти, настройки, закладки → один архив
- Импорт: распаковать архив, слить с существующими данными
- Формат: ZIP или tar.gz с JSON/SQLite внутри

### 27. Настройки внешнего вида

В V1 захардкожено. В V2 — настраиваемо.

- Размер шрифта (основной текст, код)
- Семейство моноширинного шрифта (для кода)
- Масштаб интерфейса
- Раздел в Settings

---

## Что переносим из V1

### Бэкенд (Rust) — переносим целиком
- `claude.rs` — ядро (запуск CLI, стриминг, парсинг)
- `chats.rs` — чаты, папки
- `memory.rs` — SQLite + FTS5
- `skills.rs` — SKILL.md формат
- `agents.rs` — нативные агенты CLI
- `hooks.rs` — хуки + разрешения
- `mcp.rs` — управление MCP-серверами
- `config.rs` — утилиты
- `files.rs`, `search.rs`, `projects.rs`, `attachments.rs`
- `telegram.rs`, `voice.rs`
- `plugins.rs`, `settings.rs`, `browser.rs`

### Фронтенд (React/TS) — переносим с рефакторингом
- `Layout.tsx` (2600 строк) → разбить на контексты / Zustand
- `useClaude.ts` → разбить на подхуки
- Раздутые компоненты → на 2-3 части каждый
- Все типы из `types/` переносятся

### V1 фичи (переносятся как есть)
- Настоящий стриминг (`--include-partial-messages`)
- Мульти-агент вкладки (HashMap процессов, файловые конфликты, лимит 10)
- Diff в реальном времени (Edit/Write/MultiEdit → accept/reject)
- Горизонтальная/вертикальная раскладка (переключение)
- Сворачивание длинных сообщений (>6 строк или >500 символов)
- Цитирование текста (выделить → Quote → `> prefix`)
- Follow-up цитаты внутри ответа агента
- `@ filename` — контекст файла в поле ввода
- Подсветка диапазонов строк (file:46-66)
- Кликабельные ссылки на строки в ответах агента
- Редактирование файлов прямо в FileViewer
- Перетаскивание файлов в чат, вставка картинок из буфера
- Слэш-команды (/clear, /new, /model, /copy, /rc + автокомплит)
- Избранные навыки (звёздочка, быстрый доступ)
- Лимиты сессии (max-turns, max-budget-usd)
- Дополнительные директории (--add-dir, мультипроект)
- Корректное закрытие (graceful shutdown, блокировка при активных агентах)
- Индикатор Plan/Edit режима
- Индикатор компактификации контекста
- Переменные окружения CLI (MAX_THINKING_TOKENS и пр.)
- Уровни мышления (Auto/Light/Deep)
- Режимы разрешений (6 режимов CLI)
- Fallback-модель (авто-переключение при перегрузке)
- Порты-закладки в веб-превью
- Плагины CLI (поиск, установка, запуск навыков)

### Что добавляем нового
- Встроенный MCP-инструмент (разрешения, уведомления, контекст)
- `aither-flow-perms` — отдельный бинарник для разрешений (Cargo workspace)
- Axum-сервер внутри Tauri (REST API + WebSocket, для мобилки / relay)
- `platform.rs` — кроссплатформенный модуль (macOS + Linux)
- Визард первого запуска
- Редактор глобального CLAUDE.md
- Откат сессии с восстановлением файлов (Rewind)
- Фоновый демон (systemd/launchd)
- Крон-задачи
- Worktree isolation
- Выбор бинарника Claude CLI
- Skill Sources (коллекции из репозиториев)
- Project Saves (снимки проекта)
- ESLint + Prettier + CI с первого дня

---

## Принципы (утверждены)

1. **Claude Code CLI — единственный движок.** Других нет и не будет.
2. **Чат только с Claude.** Нет переключателя на GPT/Gemini. Другие модели — инструменты через MCP.
3. **Open source, бесплатно, все фичи.** Монетизация — relay-сервис (позже).
4. **Два режима:** локальный (бесплатно) + удалённый через relay (подписка, позже).
5. **macOS + Linux.** Windows — не приоритет.
6. **Tauri 2 остаётся.** Десктоп — основная платформа.
7. **XDG-пути с первого дня.** Все конфиги в `~/.config/aither-flow/`, данные в `~/.local/share/aither-flow/`. Никакого бардака с `~/.claude-gui/` vs `~/.config/claude-gui/` как в V1. Используем `dirs` crate.
8. **Чаты и память — осознанно отделены от CLI.** GUI чаты ≠ CLI sessions (UUID-файлы). GUI память (SQLite) ≠ CLI MEMORY.md. Два мира работают параллельно, не мешают. Это решение, не баг.

---

## Не делаем / отложено

- **Локальные модели (Ollama)** — скорее откажемся, не укладывается в концепцию «CLI единственный движок»
- **RAG-базы знаний** — отложено на неопределённо
- **Вектора в памяти** — отложено, карточки + FTS5 справляются
- **Agent Teams** — экспериментальная фича CLI, слишком рано
- **Windows** — не приоритет, оба целевых OS = Unix
- **Ротация API-ключей** — не актуально пока используем подписку через CLI
- **Магазин скиллов** — риск малвари, не делаем (Skill Sources из доверенных репозиториев вместо этого)

---

## Дорожная карта: от малого ансамбля к оркестру

Не строить всё сразу. Начать с малого ансамбля (5 «инструментов»),
убедиться что работает, потом вводить новые группы.

### Этап 1 — Камерный ансамбль (MVP)
Минимальный рабочий продукт. Дирижёр + солисты.

- **Дирижёр (ядро):** запуск CLI, stream-json, стриминг, управление процессом
- **Первая скрипка (чат):** отправить сообщение → увидеть ответ → стриминг
- **Виолончель (один агент):** одна вкладка, один CLI-процесс, один проект
- **Контрабас (файлы):** FileViewer (подсветка, diff, accept/reject)
- **Фортепиано (настройки):** модель, тема, базовые параметры

Результат: можно открыть проект, поговорить с агентом, увидеть правки файлов.

### Этап 2 — Расширение струнных
Глубина работы с данными.

- Мульти-агент (несколько вкладок, изоляция)
- Чаты (сохранение, переключение, папки, поиск по истории)
- Память (SQLite + FTS5, карточки, /remember)
- Rewind (откат с восстановлением файлов)

### Этап 3 — Духовые (расширения CLI)
Инструменты, которые расширяют возможности агента.

- Навыки (SKILL.md, библиотека, избранные)
- MCP-серверы (управление, тест, OAuth)
- Агенты (CRUD, редактор, worktree)
- Хуки и разрешения (визуальный редактор)
- Интерактивные разрешения (aither-flow-perms)

### Этап 4 — Ударные (инфраструктура)
Всё что делает приложение удобнее, но не обязательно для работы.

- Веб-превью
- Поиск по проекту
- Файловый менеджер
- Голосовой ввод
- Иконки (единый пак), настройки внешнего вида
- Статистика использования

### Этап 5 — Помощник дирижёра (внешний мир)
Связь с внешним миром. Дирижёр сам никуда не звонит — у него есть помощник.

- Telegram-бот (стриминг, дебаунс, уведомления)
- Desktop-уведомления
- Relay-сервер (WebSocket, E2E)
- Крон-задачи
- Фоновый демон + трей

### Этап 6 — Полный оркестр
Полировка и продвинутые фичи.

- Визард первого запуска
- Редактор CLAUDE.md
- Перевод контента
- Менеджер сессий
- Skill Sources
- Project Saves
- Экспорт/импорт
- Кроссплатформа (macOS тестирование)

**Каждый этап обсуждается отдельно.** По каждому блоку — конкретные решения.

---

## Открытые вопросы (обсудить)

- [ ] Стейт-менеджмент: React контексты vs Zustand vs другое?
- [ ] Менеджер сессий: как визуализировать, как связать с чатами/памятью?
- [ ] Телеграм V2: какая модель взаимодействия?
- [ ] Relay-сервер: когда начинать, отдельный проект?
- [ ] Мобильный клиент: PWA vs Tauri Mobile?
- [ ] Icon pack: какой выбрать (Lucide / Phosphor / Tabler / свой)?
